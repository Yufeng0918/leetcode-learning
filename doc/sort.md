# 排序

| 序号 | 题目次数                                                     | 次数 |
| ---- | ------------------------------------------------------------ | ---- |
| 94   | [实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) | 1    |
| 212  | [单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/) | 1    |
|      |                                                              |      |
|      |                                                              |      |



## 概述

![](../images/leetcode-01.png)



### 内存消耗

原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

### 稳定性

这个概念是说，如果待排序的序列中**存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变**。

比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。



借助稳定排序算法，**我们先按照下单时间给订单排序，注意是按照下单时间**，不是金额。排序完成之后，**用稳定排序算法，按照订单金额重新排序**。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。**稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。**

![](../images/leetcode-14.jpg)



## 基础排序

冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

冒泡排序的数据交换要比插入排序的数据移动要复杂，**冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。**

![](../images/leetcode-16.jpg)



### 冒泡排序

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换

![](../images/leetcode-15.jpg)



### 插入排序

将数组中的数据分为两个区间，**已排序区间和未排序区间**。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。

![](../images/leetcode-17.jpg)



### 选择排序

分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾

![](../images/leetcode-18.jpg)

